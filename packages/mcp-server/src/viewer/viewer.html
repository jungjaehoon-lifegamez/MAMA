<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MAMA Graph Viewer</title>
  <script src="https://unpkg.com/vis-network@9/dist/vis-network.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      height: 100vh;
      overflow: hidden;
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    header {
      background: #16213e;
      padding: 12px 20px;
      border-bottom: 1px solid #4a4a6a;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    header h1 {
      font-size: 18px;
      font-weight: 600;
      color: #a0a0ff;
    }

    .stats {
      font-size: 13px;
      color: #888;
    }

    .controls {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .controls select, .controls input {
      background: #1a1a2e;
      color: #e0e0e0;
      border: 1px solid #4a4a6a;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 13px;
    }

    .controls select:focus, .controls input:focus {
      outline: none;
      border-color: #a0a0ff;
    }

    .controls input {
      width: 200px;
    }

    .search-count {
      font-size: 12px;
      color: #888;
      margin-left: 8px;
    }

    #graph-container {
      flex: 1;
      background: #1a1a2e;
      width: 100%;
      height: calc(100vh - 50px);
      position: relative;
    }

    #detail-panel {
      display: none;
      position: fixed;
      right: 20px;
      top: 80px;
      width: 350px;
      max-height: calc(100vh - 100px);
      background: #16213e;
      border: 1px solid #4a4a6a;
      border-radius: 8px;
      padding: 16px;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
    }

    #detail-panel.visible {
      display: block;
    }

    #detail-panel h3 {
      color: #a0a0ff;
      margin-bottom: 12px;
      font-size: 14px;
    }

    #detail-panel .field {
      margin-bottom: 10px;
    }

    #detail-panel .field-label {
      font-size: 11px;
      color: #888;
      text-transform: uppercase;
      margin-bottom: 4px;
    }

    #detail-panel .field-value {
      font-size: 13px;
      color: #e0e0e0;
      line-height: 1.5;
    }

    #detail-panel .close-btn {
      position: absolute;
      top: 12px;
      right: 12px;
      background: none;
      border: none;
      color: #888;
      cursor: pointer;
      font-size: 18px;
    }

    #detail-panel .close-btn:hover {
      color: #fff;
    }

    #detail-panel .reasoning-toggle {
      cursor: pointer;
      user-select: none;
    }

    #detail-panel .reasoning-toggle::before {
      content: '▶ ';
      font-size: 10px;
    }

    #detail-panel .reasoning-toggle.expanded::before {
      content: '▼ ';
    }

    #detail-panel .reasoning-content {
      display: none;
      margin-top: 8px;
      padding: 8px;
      background: #1a1a2e;
      border-radius: 4px;
      white-space: pre-wrap;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
    }

    #detail-panel .reasoning-content.visible {
      display: block;
    }

    #detail-panel .edges-list {
      margin-top: 8px;
    }

    #detail-panel .edge-item {
      font-size: 12px;
      padding: 4px 0;
      color: #aaa;
    }

    #detail-panel .edge-item .edge-arrow {
      margin: 0 4px;
    }

    #detail-panel .edge-item .edge-type {
      color: #888;
      font-style: italic;
    }

    /* Similar Decisions */
    .similar-list {
      max-height: 180px;
      overflow-y: auto;
    }

    .similar-item {
      padding: 6px 8px;
      margin: 4px 0;
      background: #1a1a2e;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
      font-size: 12px;
    }

    .similar-item:hover {
      background: #2a2a4e;
    }

    .similar-item .similar-topic {
      font-weight: 500;
      color: #a0a0ff;
    }

    .similar-item .similar-decision {
      color: #aaa;
      font-size: 11px;
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .similar-item .similar-score {
      float: right;
      font-size: 10px;
      color: #666;
      background: #2a2a4e;
      padding: 2px 6px;
      border-radius: 10px;
    }

    .loading-similar {
      color: #666;
      font-style: italic;
    }

    /* Story 3.3: Outcome Editing */
    .outcome-edit {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .outcome-edit select {
      background: #1a1a2e;
      color: #e0e0e0;
      border: 1px solid #4a4a6a;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
    }

    .outcome-edit select:focus {
      outline: none;
      border-color: #a0a0ff;
    }

    .save-btn {
      background: #4a4a6a;
      color: #e0e0e0;
      border: none;
      padding: 4px 12px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .save-btn:hover {
      background: #5a5a7a;
    }

    .save-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #outcome-status {
      font-size: 11px;
    }

    #outcome-status.success {
      color: #22c55e;
    }

    #outcome-status.error {
      color: #ef4444;
    }

    .loading {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100%;
      color: #888;
      font-size: 14px;
    }

    .error {
      color: #ff6b6b;
      text-align: center;
      padding: 20px;
    }

    /* Legend Panel */
    #legend-panel {
      position: fixed;
      left: 20px;
      bottom: 20px;
      background: #16213e;
      border: 1px solid #4a4a6a;
      border-radius: 8px;
      padding: 12px 16px;
      padding-top: 16px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      z-index: 100;
      min-width: 180px;
    }

    #legend-panel h4 {
      color: #a0a0ff;
      font-size: 12px;
      margin-bottom: 10px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .legend-section {
      margin-bottom: 12px;
    }

    .legend-section:last-child {
      margin-bottom: 0;
    }

    .legend-section-title {
      font-size: 10px;
      color: #888;
      text-transform: uppercase;
      margin-bottom: 6px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 4px 0;
      font-size: 11px;
      color: #e0e0e0;
    }

    .legend-edge {
      width: 30px;
      height: 2px;
      position: relative;
    }

    .legend-edge.dashed {
      background: repeating-linear-gradient(
        90deg,
        currentColor 0px,
        currentColor 5px,
        transparent 5px,
        transparent 10px
      );
      height: 2px;
    }

    .legend-edge.solid {
      background: currentColor;
    }

    .legend-edge.thick {
      height: 3px;
    }

    .legend-node {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid #4a4a6a;
    }

    .legend-node.small {
      width: 10px;
      height: 10px;
    }

    .legend-node.medium {
      width: 14px;
      height: 14px;
    }

    .legend-node.large {
      width: 18px;
      height: 18px;
    }

    .legend-toggle {
      position: fixed;
      left: 20px;
      bottom: 20px;
      background: #16213e;
      border: 1px solid #4a4a6a;
      border-radius: 4px;
      padding: 6px 10px;
      color: #a0a0ff;
      cursor: pointer;
      font-size: 11px;
      z-index: 99;
      display: none;
    }

    .legend-toggle:hover {
      background: #1a2a4e;
    }

    #legend-panel.collapsed {
      display: none;
    }

    #legend-panel.collapsed + .legend-toggle {
      display: block;
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>MAMA Reasoning Graph</h1>
      <div class="controls">
        <select id="topic-filter" onchange="filterByTopic(this.value)">
          <option value="">All Topics</option>
        </select>
        <input type="text" id="search-input" placeholder="Search... (press /)"
               onkeyup="handleSearch(event)" style="display:none;">
      </div>
      <div class="stats" id="stats">Loading...</div>
    </header>
    <div id="graph-container">
      <div class="loading" id="loading">Loading graph data...</div>
    </div>
    <div id="detail-panel">
      <button class="close-btn" onclick="closeDetail()">&times;</button>
      <h3 id="detail-topic">Topic</h3>
      <div class="field">
        <div class="field-label">Decision</div>
        <div class="field-value" id="detail-decision"></div>
      </div>
      <div class="field">
        <div class="field-label reasoning-toggle" id="reasoning-toggle" onclick="toggleReasoning()">Reasoning</div>
        <div class="field-value reasoning-content" id="detail-reasoning"></div>
      </div>
      <div class="field">
        <div class="field-label">Similar Decisions</div>
        <div class="field-value similar-list" id="detail-similar">
          <span class="loading-similar">Searching...</span>
        </div>
      </div>
      <div class="field">
        <div class="field-label">Outcome</div>
        <div class="field-value outcome-edit">
          <select id="detail-outcome-select">
            <option value="PENDING">PENDING</option>
            <option value="SUCCESS">SUCCESS</option>
            <option value="FAILED">FAILED</option>
            <option value="PARTIAL">PARTIAL</option>
          </select>
          <button onclick="saveOutcome()" class="save-btn">Save</button>
          <span id="outcome-status"></span>
        </div>
      </div>
      <div class="field">
        <div class="field-label">Confidence</div>
        <div class="field-value" id="detail-confidence"></div>
      </div>
      <div class="field">
        <div class="field-label">Created</div>
        <div class="field-value" id="detail-created"></div>
      </div>
    </div>

    <!-- Legend Panel -->
    <div id="legend-panel">
      <button class="close-btn" onclick="toggleLegend()" style="position:absolute;top:8px;right:8px;">&times;</button>
      <h4>Legend</h4>
      <div class="legend-section">
        <div class="legend-section-title">Edge Types</div>
        <div class="legend-item">
          <span class="legend-edge solid" style="color: #848484;"></span>
          <span>supersedes</span>
        </div>
        <div class="legend-item">
          <span class="legend-edge dashed" style="color: #457b9d;"></span>
          <span>builds_on</span>
        </div>
        <div class="legend-item">
          <span class="legend-edge dashed" style="color: #e63946;"></span>
          <span>debates</span>
        </div>
        <div class="legend-item">
          <span class="legend-edge solid thick" style="color: #9b59b6;"></span>
          <span>synthesizes</span>
        </div>
      </div>
      <div class="legend-section">
        <div class="legend-section-title">Node Size</div>
        <div class="legend-item">
          <span class="legend-node small" style="background: #6366f1;"></span>
          <span>1-2 connections</span>
        </div>
        <div class="legend-item">
          <span class="legend-node medium" style="background: #6366f1;"></span>
          <span>3-5 connections</span>
        </div>
        <div class="legend-item">
          <span class="legend-node large" style="background: #6366f1;"></span>
          <span>6+ connections</span>
        </div>
      </div>
    </div>
    <button class="legend-toggle" onclick="toggleLegend()">Show Legend</button>
  </div>

  <script>
    // Global state
    let network = null;
    let graphData = { nodes: [], edges: [], meta: {} };
    let currentNodeId = null; // Track selected node for outcome editing

    // Color palette for topics
    const topicColors = {};
    const colorPalette = [
      '#6366f1', '#8b5cf6', '#a855f7', '#d946ef',
      '#ec4899', '#f43f5e', '#ef4444', '#f97316',
      '#f59e0b', '#eab308', '#84cc16', '#22c55e',
      '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9'
    ];
    let colorIndex = 0;

    function getTopicColor(topic) {
      if (!topicColors[topic]) {
        topicColors[topic] = colorPalette[colorIndex % colorPalette.length];
        colorIndex++;
      }
      return topicColors[topic];
    }

    // Edge styles by relationship type (Story 2.3)
    const EDGE_STYLES = {
      supersedes: { color: '#848484', dashes: false },
      builds_on: { color: '#457b9d', dashes: [5, 5] },
      debates: { color: '#e63946', dashes: [5, 5] },
      synthesizes: { color: '#9b59b6', width: 3, dashes: false }
    };

    function getEdgeStyle(relationship) {
      return EDGE_STYLES[relationship] || { color: '#4a4a6a', dashes: false };
    }

    // Fetch graph data from API
    async function fetchGraphData() {
      try {
        // Include cluster=true for similarity-based layout
        const response = await fetch('/graph?cluster=true');
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        graphData = await response.json();
        console.log('[MAMA] Graph data loaded:', graphData.meta);
        return graphData;
      } catch (error) {
        console.error('[MAMA] Failed to fetch graph:', error);
        throw error;
      }
    }

    // Calculate node size based on connection count
    function getNodeSize(connectionCount) {
      if (connectionCount <= 2) return 12;      // Small: 1-2 connections
      if (connectionCount <= 5) return 18;      // Medium: 3-5 connections
      if (connectionCount <= 10) return 24;     // Large: 6-10 connections
      return 30;                                 // Extra large: 11+ connections
    }

    // Calculate connection count for each node
    function calculateConnectionCounts(nodes, edges) {
      const counts = {};
      nodes.forEach(n => counts[n.id] = 0);

      edges.forEach(edge => {
        if (counts[edge.from] !== undefined) counts[edge.from]++;
        if (counts[edge.to] !== undefined) counts[edge.to]++;
      });

      return counts;
    }

    // Initialize vis-network
    function initGraph(data) {
      const container = document.getElementById('graph-container');
      // Remove loading element completely
      const loadingEl = document.getElementById('loading');
      if (loadingEl) loadingEl.remove();

      console.log('[MAMA] Initializing graph with', data.nodes.length, 'nodes');

      // Calculate connection counts for node sizing
      const connectionCounts = calculateConnectionCounts(data.nodes, data.edges);
      console.log('[MAMA] Connection counts calculated');

      // Transform nodes for vis-network with size based on connections
      visNodes = new vis.DataSet(
        data.nodes.map(node => {
          const connCount = connectionCounts[node.id] || 0;
          const nodeSize = getNodeSize(connCount);
          return {
            id: node.id,
            label: node.topic,
            title: `${node.decision}\n\nConnections: ${connCount}`,
            size: nodeSize,
            color: {
              background: getTopicColor(node.topic),
              border: '#4a4a6a',
              highlight: {
                background: getTopicColor(node.topic),
                border: '#a0a0ff'
              }
            },
            font: { color: '#fff', size: Math.max(10, nodeSize * 0.7) },
            // Store original data with connection count
            data: { ...node, connectionCount: connCount }
          };
        })
      );

      // Transform edges for vis-network with relationship styling (Story 2.3)
      const allEdges = data.edges.map((edge, idx) => {
        const style = getEdgeStyle(edge.relationship);
        return {
          id: `edge_${idx}`,
          from: edge.from,
          to: edge.to,
          label: edge.relationship,
          arrows: 'to',
          color: { color: style.color, highlight: '#a0a0ff' },
          dashes: style.dashes,
          width: style.width || 1,
          font: { color: '#888', size: 10 },
          // Store original data
          data: edge
        };
      });

      // Add similarity edges (hidden, for physics clustering only)
      if (data.similarityEdges && data.similarityEdges.length > 0) {
        console.log('[MAMA] Adding', data.similarityEdges.length, 'similarity edges for clustering');
        data.similarityEdges.forEach((edge, idx) => {
          allEdges.push({
            id: `sim_${idx}`,
            from: edge.from,
            to: edge.to,
            // Hidden edge for physics only
            hidden: true,
            physics: true,
            // Looser clustering - more distance between similar nodes
            length: Math.max(150, 400 * (1 - edge.similarity)),
            // Store similarity data
            data: { ...edge, isSimilarity: true }
          });
        });
      }

      visEdges = new vis.DataSet(allEdges);

      const options = {
        nodes: {
          shape: 'dot',
          size: 16,
          borderWidth: 2
        },
        edges: {
          width: 1,
          smooth: { type: 'continuous' }
        },
        layout: {
          improvedLayout: false  // Disable for large graphs
        },
        physics: {
          stabilization: {
            enabled: true,
            iterations: 200,
            updateInterval: 25
          },
          barnesHut: {
            gravitationalConstant: -5000,
            centralGravity: 0.2,
            springLength: 200,
            springConstant: 0.03,
            damping: 0.09
          }
        },
        interaction: {
          hover: true,
          tooltipDelay: 200,
          hideEdgesOnDrag: true,
          hideEdgesOnZoom: true
        }
      };

      network = new vis.Network(container, { nodes: visNodes, edges: visEdges }, options);

      // Fit graph to view after stabilization
      network.once('stabilizationIterationsDone', function() {
        network.fit();
        console.log('[MAMA] Graph stabilized, fitting to view');
      });

      // Also fit after a timeout in case stabilization is disabled
      setTimeout(() => {
        network.fit();
        console.log('[MAMA] Network fit called, nodes:', visNodes.length);
      }, 1000);

      // Node click handler
      network.on('click', function(params) {
        if (params.nodes.length > 0) {
          const nodeId = params.nodes[0];
          const node = visNodes.get(nodeId);
          showDetail(node.data);
          highlightConnectedNodes(nodeId);
        } else {
          closeDetail();
          resetNodeHighlight();
        }
      });

      // Update stats and populate topic filter
      updateStats(data.meta);
      populateTopicFilter(data.meta.topics);
    }

    // Get all nodes connected to a given node (via edges) up to specified depth
    function getConnectedNodeIds(nodeId, maxDepth = 3) {
      const connected = new Set([nodeId]);
      const depthMap = new Map([[nodeId, 0]]); // Track depth of each node
      let currentDepth = 0;
      let frontier = new Set([nodeId]);

      while (currentDepth < maxDepth && frontier.size > 0) {
        const nextFrontier = new Set();

        frontier.forEach(currentId => {
          graphData.edges.forEach(edge => {
            let neighborId = null;
            if (edge.from === currentId) neighborId = edge.to;
            if (edge.to === currentId) neighborId = edge.from;

            if (neighborId && !connected.has(neighborId)) {
              connected.add(neighborId);
              depthMap.set(neighborId, currentDepth + 1);
              nextFrontier.add(neighborId);
            }
          });
        });

        frontier = nextFrontier;
        currentDepth++;
      }

      return { connected, depthMap };
    }

    // Highlight selected node and its connected nodes, dim others
    function highlightConnectedNodes(nodeId) {
      if (!visNodes || !visEdges) return;

      const { connected, depthMap } = getConnectedNodeIds(nodeId, 3);

      // Opacity by depth: 0=selected(1.0), 1=direct(0.9), 2=second(0.7), 3=third(0.5)
      const depthOpacity = [1.0, 0.9, 0.7, 0.5];

      // Update nodes
      const nodeUpdates = graphData.nodes.map(node => {
        const isConnected = connected.has(node.id);
        const isSelected = node.id === nodeId;
        const depth = depthMap.get(node.id);
        const connCount = node.connectionCount || 0;
        const nodeSize = getNodeSize(connCount);

        // Calculate opacity based on depth
        const opacity = isConnected ? (depthOpacity[depth] || 0.5) : 0.1;
        const textOpacity = isConnected ? Math.max(0.4, opacity) : 0.1;

        return {
          id: node.id,
          opacity: opacity,
          // Make selected node slightly larger
          borderWidth: isSelected ? 4 : 2,
          color: {
            background: isConnected ? getTopicColor(node.topic) : '#555',
            border: isSelected ? '#fff' : (isConnected ? '#4a4a6a' : '#333'),
            highlight: {
              background: getTopicColor(node.topic),
              border: '#a0a0ff'
            }
          },
          // Dim text for non-connected nodes
          font: {
            color: isConnected ? `rgba(255,255,255,${textOpacity})` : 'rgba(255,255,255,0.1)',
            size: Math.max(10, nodeSize * 0.7)
          }
        };
      });

      visNodes.update(nodeUpdates);

      // Update edges - dim edges not connected to the subgraph
      const edgeUpdates = visEdges.get().map(edge => {
        // Skip hidden edges (similarity edges)
        if (edge.hidden) return null;

        const fromConnected = connected.has(edge.from);
        const toConnected = connected.has(edge.to);
        const isConnectedEdge = fromConnected && toConnected;
        const style = getEdgeStyle(edge.data?.relationship);

        return {
          id: edge.id,
          color: {
            color: isConnectedEdge ? style.color : 'rgba(80,80,80,0.15)',
            highlight: '#a0a0ff',
            opacity: isConnectedEdge ? 1 : 0.1
          },
          width: isConnectedEdge ? (style.width || 1) : 0.5,
          font: {
            color: isConnectedEdge ? 'rgba(136,136,136,1)' : 'rgba(136,136,136,0)',
            size: 10,
            strokeWidth: 0,
            background: 'transparent'
          }
        };
      }).filter(Boolean);

      visEdges.update(edgeUpdates);
    }

    // Reset all nodes and edges to normal state
    function resetNodeHighlight() {
      if (!visNodes || !visEdges) return;

      // Reset nodes
      const nodeUpdates = graphData.nodes.map(node => {
        const connCount = node.connectionCount || 0;
        const nodeSize = getNodeSize(connCount);

        return {
          id: node.id,
          opacity: 1,
          borderWidth: 2,
          color: {
            background: getTopicColor(node.topic),
            border: '#4a4a6a',
            highlight: {
              background: getTopicColor(node.topic),
              border: '#a0a0ff'
            }
          },
          font: {
            color: '#fff',
            size: Math.max(10, nodeSize * 0.7)
          }
        };
      });

      visNodes.update(nodeUpdates);

      // Reset edges
      const edgeUpdates = visEdges.get().map(edge => {
        // Skip hidden edges (similarity edges)
        if (edge.hidden) return null;

        const style = getEdgeStyle(edge.data?.relationship);

        return {
          id: edge.id,
          color: {
            color: style.color,
            highlight: '#a0a0ff',
            opacity: 1
          },
          width: style.width || 1,
          font: {
            color: '#888',
            size: 10,
            strokeWidth: 0,
            background: 'transparent'
          }
        };
      }).filter(Boolean);

      visEdges.update(edgeUpdates);
    }

    function updateStats(meta) {
      const statsEl = document.getElementById('stats');
      statsEl.textContent = `${meta.total_nodes} decisions | ${meta.total_edges} edges | ${meta.topics.length} topics`;
    }

    function showDetail(node) {
      const panel = document.getElementById('detail-panel');
      currentNodeId = node.id; // Track current node for outcome editing

      document.getElementById('detail-topic').textContent = node.topic;
      document.getElementById('detail-decision').textContent = node.decision || '-';
      document.getElementById('detail-reasoning').textContent = node.reasoning || '-';

      // Story 3.3: Set outcome dropdown value
      const outcomeSelect = document.getElementById('detail-outcome-select');
      outcomeSelect.value = (node.outcome || 'PENDING').toUpperCase();
      document.getElementById('outcome-status').textContent = '';
      document.getElementById('outcome-status').className = '';

      document.getElementById('detail-confidence').textContent = node.confidence ? `${(node.confidence * 100).toFixed(0)}%` : '-';
      document.getElementById('detail-created').textContent = node.created_at ? new Date(node.created_at).toLocaleString() : '-';

      // Reset reasoning toggle state (Story 2.4)
      document.getElementById('reasoning-toggle').classList.remove('expanded');
      document.getElementById('detail-reasoning').classList.remove('visible');

      // Fetch and show similar decisions
      document.getElementById('detail-similar').innerHTML = '<span class="loading-similar">Searching...</span>';
      fetchSimilarDecisions(node.id);

      panel.classList.add('visible');
    }

    // Fetch similar decisions via API
    async function fetchSimilarDecisions(nodeId) {
      try {
        const response = await fetch(`/graph/similar?id=${encodeURIComponent(nodeId)}`);
        const data = await response.json();

        if (data.error) {
          document.getElementById('detail-similar').innerHTML =
            `<span style="color:#666">${data.message || 'Search failed'}</span>`;
          return;
        }

        if (!data.similar || data.similar.length === 0) {
          document.getElementById('detail-similar').innerHTML =
            '<span style="color:#666">No similar decisions found</span>';
          return;
        }

        // Render similar decisions
        const html = data.similar.map(s => `
          <div class="similar-item" onclick="navigateToNode('${s.id}')">
            <span class="similar-score">${Math.round(s.similarity * 100)}%</span>
            <div class="similar-topic">${escapeHtml(s.topic)}</div>
            <div class="similar-decision">${escapeHtml(s.decision || '-')}</div>
          </div>
        `).join('');

        document.getElementById('detail-similar').innerHTML = html;
      } catch (error) {
        console.error('[MAMA] Similar search error:', error);
        document.getElementById('detail-similar').innerHTML =
          '<span style="color:#f66">Error loading similar decisions</span>';
      }
    }

    // Navigate to a node in the graph
    function navigateToNode(nodeId) {
      if (!network || !visNodes) return;

      // Check if node exists in current view
      const node = visNodes.get(nodeId);
      if (!node) {
        // Node might be hidden due to filter, show all first
        filterByTopic('');
        document.getElementById('topic-filter').value = '';
      }

      // Focus and select the node
      network.focus(nodeId, { scale: 1.2, animation: true });
      network.selectNodes([nodeId]);

      // Show its detail panel
      const nodeData = graphData.nodes.find(n => n.id === nodeId);
      if (nodeData) {
        showDetail(nodeData);
      }
    }

    // HTML escape utility
    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function closeDetail() {
      document.getElementById('detail-panel').classList.remove('visible');
      currentNodeId = null;
      resetNodeHighlight();
    }

    // Toggle legend visibility
    function toggleLegend() {
      const legend = document.getElementById('legend-panel');
      legend.classList.toggle('collapsed');
    }

    // Story 3.3: Save outcome via API
    async function saveOutcome() {
      if (!currentNodeId) return;

      const outcomeSelect = document.getElementById('detail-outcome-select');
      const statusEl = document.getElementById('outcome-status');
      const saveBtn = document.querySelector('.save-btn');
      const newOutcome = outcomeSelect.value;

      // Disable button during save
      saveBtn.disabled = true;
      statusEl.textContent = 'Saving...';
      statusEl.className = '';

      try {
        const response = await fetch('/graph/update', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            id: currentNodeId,
            outcome: newOutcome
          })
        });

        const result = await response.json();

        if (result.success) {
          statusEl.textContent = '✓ Saved';
          statusEl.className = 'success';

          // Update local data
          const node = graphData.nodes.find(n => n.id === currentNodeId);
          if (node) {
            node.outcome = newOutcome;
          }
        } else {
          statusEl.textContent = result.message || 'Failed';
          statusEl.className = 'error';
        }
      } catch (error) {
        console.error('[MAMA] Save outcome error:', error);
        statusEl.textContent = 'Error: ' + error.message;
        statusEl.className = 'error';
      } finally {
        saveBtn.disabled = false;
        // Clear status after 3 seconds
        setTimeout(() => {
          if (statusEl.textContent.startsWith('✓')) {
            statusEl.textContent = '';
            statusEl.className = '';
          }
        }, 3000);
      }
    }

    // Toggle reasoning collapse/expand (Story 2.4)
    function toggleReasoning() {
      const toggle = document.getElementById('reasoning-toggle');
      const content = document.getElementById('detail-reasoning');
      toggle.classList.toggle('expanded');
      content.classList.toggle('visible');
    }

    // Get edges connected to a node (Story 2.4)
    function getConnectedEdges(nodeId) {
      const connected = graphData.edges.filter(e => e.from === nodeId || e.to === nodeId);
      if (connected.length === 0) return '';

      return connected.map(edge => {
        const isOutgoing = edge.from === nodeId;
        const arrow = isOutgoing ? '→' : '←';
        const targetId = isOutgoing ? edge.to : edge.from;
        const targetNode = graphData.nodes.find(n => n.id === targetId);
        const targetLabel = targetNode ? targetNode.topic : targetId.substring(0, 20);
        return `<div class="edge-item"><span class="edge-arrow">${arrow}</span><span class="edge-type">${edge.relationship}</span>: ${targetLabel}</div>`;
      }).join('');
    }

    // Story 3.2: Topic Dropdown Filter
    function populateTopicFilter(topics) {
      const select = document.getElementById('topic-filter');
      topics.forEach(topic => {
        const option = document.createElement('option');
        option.value = topic;
        option.textContent = topic;
        select.appendChild(option);
      });

      // Check URL for initial filter
      const urlParams = new URLSearchParams(window.location.search);
      const topicParam = urlParams.get('topic');
      if (topicParam) {
        select.value = topicParam;
        filterByTopic(topicParam);
      }
    }

    let visNodes = null; // Store reference to vis.DataSet for nodes
    let visEdges = null; // Store reference to vis.DataSet for edges

    function filterByTopic(topic) {
      if (!visNodes) return;

      // Update URL
      const url = new URL(window.location);
      if (topic) {
        url.searchParams.set('topic', topic);
      } else {
        url.searchParams.delete('topic');
      }
      history.pushState({}, '', url);

      // Update node visibility
      const updates = graphData.nodes.map(node => ({
        id: node.id,
        hidden: topic ? node.topic !== topic : false,
        opacity: topic ? (node.topic === topic ? 1 : 0.15) : 1
      }));
      visNodes.update(updates);

      // Fit to visible nodes
      setTimeout(() => network.fit(), 100);
    }

    // Story 3.1: Keyword Search
    let searchMatches = [];
    let searchIndex = 0;

    function handleSearch(event) {
      const query = event.target.value.toLowerCase().trim();

      if (event.key === 'Escape') {
        closeSearch();
        return;
      }

      if (event.key === 'Enter' && searchMatches.length > 0) {
        searchIndex = (searchIndex + 1) % searchMatches.length;
        focusMatch();
        return;
      }

      if (!query) {
        clearHighlight();
        return;
      }

      // Search nodes
      searchMatches = graphData.nodes.filter(node =>
        (node.topic && node.topic.toLowerCase().includes(query)) ||
        (node.decision && node.decision.toLowerCase().includes(query)) ||
        (node.reasoning && node.reasoning.toLowerCase().includes(query))
      ).map(n => n.id);

      searchIndex = 0;

      if (searchMatches.length > 0) {
        highlightMatches();
        focusMatch();
      } else {
        clearHighlight();
      }

      // Update count display
      updateSearchCount();
    }

    function highlightMatches() {
      if (!visNodes) return;
      const updates = graphData.nodes.map(node => ({
        id: node.id,
        opacity: searchMatches.includes(node.id) ? 1 : 0.2
      }));
      visNodes.update(updates);
      network.selectNodes(searchMatches);
    }

    function clearHighlight() {
      if (!visNodes) return;
      const updates = graphData.nodes.map(node => ({
        id: node.id,
        opacity: 1
      }));
      visNodes.update(updates);
      network.unselectAll();
      searchMatches = [];
    }

    function focusMatch() {
      if (searchMatches.length === 0) return;
      const nodeId = searchMatches[searchIndex];
      network.focus(nodeId, { scale: 1.2, animation: true });
      network.selectNodes([nodeId]);
      updateSearchCount();
    }

    function updateSearchCount() {
      const input = document.getElementById('search-input');
      let countEl = document.querySelector('.search-count');
      if (!countEl) {
        countEl = document.createElement('span');
        countEl.className = 'search-count';
        input.parentNode.appendChild(countEl);
      }
      if (searchMatches.length > 0) {
        countEl.textContent = `${searchIndex + 1}/${searchMatches.length}`;
      } else if (input.value) {
        countEl.textContent = 'No matches';
      } else {
        countEl.textContent = '';
      }
    }

    function openSearch() {
      const input = document.getElementById('search-input');
      input.style.display = 'block';
      input.focus();
    }

    function closeSearch() {
      const input = document.getElementById('search-input');
      input.style.display = 'none';
      input.value = '';
      clearHighlight();
      updateSearchCount();
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Ignore if typing in an input
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
        if (e.key === 'Escape') closeSearch();
        return;
      }

      if (e.key === '/') {
        e.preventDefault();
        openSearch();
      } else if (e.key === 'Escape') {
        closeSearch();
        closeDetail();
      }
    });

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', async () => {
      try {
        const data = await fetchGraphData();
        if (data.nodes.length === 0) {
          document.getElementById('loading').innerHTML = '<div class="error">No decisions found. Start making decisions with MAMA!</div>';
          return;
        }
        initGraph(data);
      } catch (error) {
        document.getElementById('loading').innerHTML = `<div class="error">Failed to load graph: ${error.message}</div>`;
      }
    });
  </script>
</body>
</html>
